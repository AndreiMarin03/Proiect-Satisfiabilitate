import re
import random
from collections import defaultdict


def valida_2cnf_sintaxa(formula_str):
    formula_str = formula_str.replace(" ", "")
    if not re.fullmatch(r'[\w\-âˆ¨âˆ§()]+', formula_str):
        return False
    clauze = split_clauze(formula_str)
    for clauza in clauze:
        clauza = clauza.strip('()')
        literali = re.split(r'âˆ¨', clauza)
        if len(literali) != 2:
            return False
        for lit in literali:
            if not re.fullmatch(r'-?\w+', lit):
                return False
    return True
def split_clauze(formula_str):
    clauze = []
    stack = 0
    curent = []
    for char in formula_str:
        if char == '(': stack += 1
        elif char == ')': stack -= 1
        curent.append(char)
        if char == 'âˆ§' and stack == 0:
            clauze.append(''.join(curent[:-1]).strip())
            curent = []
    if curent:
        clauze.append(''.join(curent).strip())
    return clauze


def formula_parsata(input_str):
    try:
        input_str = input_str.replace(" ", "")
        print("\n[PARSARE] Input iniÈ›ial:", input_str)

        if not valida_2cnf_sintaxa(input_str):
            raise ValueError("Formula nu este Ã®n 2-CNF valid!")

        clauze = split_clauze(input_str)
        formula = []
        for clauza in clauze:
            clauza = clauza.strip('()')
            literali = [lit.strip() for lit in clauza.split('âˆ¨')]
            formula.append(literali)

        return formula

    except Exception as e:
        print(f"\n[EROARE] {str(e)}")
        print("Exemple valide: (a âˆ¨ -b) âˆ§ (c âˆ¨ d), (1 âˆ¨ -2) âˆ§ (-x3 âˆ¨ y)")
        return None
def propagarea_unitatii(formula, assignment, verbose=False):
    changed = True
    while changed:
        changed = False
        if verbose:
            print(f"\n[Unit Propagate] Clauze: {formula}")
            print(f"Atribuire curentÄƒ: {assignment}")
        for clause in formula[:]:
            if len(clause) == 1:
                lit = clause[0]
                if isinstance(lit, str):
                    neg_lit = lit[1:] if lit.startswith('-') else f"-{lit}"
                else:
                    neg_lit = -lit

                if neg_lit in assignment:
                    return None, None
                if lit not in assignment:
                    if verbose:  # Fix aici
                        print(f"â‡’ AlocÄƒm {lit} din clauza unitarÄƒ {clause}")
                    assignment.add(lit)
                    changed = True
                    formula = [c for c in formula if lit not in c]
                    formula = [[l for l in c if l != neg_lit] for c in formula]
    return formula, assignment

def jeroslow_wang_heuristic(formula, assignment):
    literal_counts = defaultdict(int)
    for clause in formula:
        # IgnorÄƒ clauzele deja satisfÄƒcute
        if any(lit in assignment for lit in clause):
            continue
        for lit in clause:
            if isinstance(lit, str):
                neg_lit = lit[1:] if lit.startswith('-') else f"-{lit}"
            else:
                neg_lit = -lit

            if neg_lit not in assignment:  # Literalul nu e fals Ã®ncÄƒ
                var = lit[1:] if isinstance(lit, str) and lit.startswith('-') else lit
                literal_counts[var] += 1
    return max(literal_counts, key=literal_counts.get, default=None)


def satisfies_clause(clause, assignment):
    return any(lit in assignment for lit in clause)


def dpll(formula, assignment=None, verbose=False):
    if assignment is None:
        assignment = set()
    if verbose:
        print(f"\n[DPLL] CÄƒutare cu asignarea: {assignment}")
    # VerificÄƒ dacÄƒ toate clauzele sunt satisfÄƒcute
    if all(satisfies_clause(clause, assignment) for clause in formula):
        return True, assignment

    # DacÄƒ existÄƒ o clauzÄƒ goalÄƒ (nesatisfÄƒcutÄƒ)
    if any(not clause for clause in formula):
        return False, None

    formula, assignment = propagarea_unitatii(formula, assignment, verbose)
    if formula is None:  # ContradicÈ›ie Ã®n unit_propagate
        return False, None

    var = jeroslow_wang_heuristic(formula, assignment)
    if var is None:
        return False, None  # Nu mai sunt variabile, dar clauzele nu sunt toate satisfÄƒcute

    for value in [var, f"-{var}" if isinstance(var, str) else -var]:
        new_assignment = set(assignment) | {value}
        sat, result = dpll(formula, new_assignment, verbose)  # Fix aici
        if sat:
            return sat, result

    return False, None


def dp(formula, verbose=False):
    formula = [set(clause) for clause in formula]
    formula = scoate_tautologii(formula)  # Pas 1: EliminÄƒ tautologiile iniÈ›iale
    step = 0

    while True:
        formula = scoate_tautologii(formula)  # Pas 2: CurÄƒÈ›Äƒ formula la fiecare iteraÈ›ie

        if verbose:
            print(f"\n=== Pasul {step} ===")
            print("Formula curentÄƒ:")
            for i, clause in enumerate(formula, 1):
                print(f"Clauza {i}: {clause}")
            print("=" * 40)

        # VerificÄƒ dacÄƒ existÄƒ variabile rÄƒmase
        vars_in_formula = set()
        for clause in formula:
            for lit in clause:
                var = lit[1:] if lit.startswith('-') else lit
                vars_in_formula.add(var)
        if not vars_in_formula:
            if verbose:
                print("Nu existÄƒ variabile rÄƒmase - Formula SATISFIABILÄ‚")
            return True

        # Alege variabila de rezolvat
        x = next(iter(vars_in_formula))
        if verbose:
            print(f"\nProcesare variabilÄƒ: {x}")

        # IdentificÄƒ clauzele pozitive È™i negative
        pos = [c for c in formula if x in c]
        neg = [c for c in formula if f"-{x}" in c]

        if verbose:
            print(f"Clauze pozitive ({len(pos)}): {pos}")
            print(f"Clauze negative ({len(neg)}): {neg}")

        # GenereazÄƒ rezolventele È™i eliminÄƒ tautologiile
        resolvents = []
        for c1 in pos:
            for c2 in neg:
                resolvent = (c1 | c2) - {x, f"-{x}"}
                if resolvent:  # IgnorÄƒ rezolventele vide
                    # VerificÄƒ dacÄƒ rezolventul este tautologie
                    is_tautology = any(
                        (lit in resolvent and f"-{lit}" in resolvent)
                        or (f"-{lit}" in resolvent and lit in resolvent)
                        for lit in resolvent
                    )
                    if not is_tautology:
                        resolvents.append(resolvent)
                else:
                    if verbose:
                        print("â•" * 60)
                        print("â— S-a generat clauza vidÄƒ!")
                        print("â•" * 60)
                    return False

        # ConstruieÈ™te noua formulÄƒ
        new_formula = [
            c for c in formula
            if x not in c and f"-{x}" not in c
        ] + resolvents

        formula = new_formula
        step += 1

        if verbose:
            print(f"\nNoua formulÄƒ dupÄƒ pasul {step}:")
            for i, clause in enumerate(formula, 1):
                print(f"Clauza {i}: {clause}")
            print("=" * 40)
def genereaza_2cnf_formula(n_vars, n_clauses, force_unsat=False):
    formula = []
    vars_list = [str(i + 1) for i in range(n_vars)] + [chr(ord('a') + i) for i in range(min(n_vars, 26))]

    # GenerÄƒm o atribuire aleatoare pentru a asigura satisfiabilitatea
    assignment = {var: random.choice([True, False]) for var in vars_list}

    for _ in range(n_clauses):
        # Alegem doi literali care nu sunt amÃ¢ndoi falÈ™i Ã®n atribuire
        valid = False
        attempts = 0
        while not valid and attempts < 100:
            a_var = random.choice(vars_list)
            a_neg = random.choice([True, False])
            a_lit = f"-{a_var}" if a_neg else a_var
            a_val = not a_neg if assignment[a_var] else a_neg

            b_var = random.choice(vars_list)
            b_neg = random.choice([True, False])
            b_lit = f"-{b_var}" if b_neg else b_var
            b_val = not b_neg if assignment[b_var] else b_neg

            if a_val or b_val:  # Cel puÈ›in un literal adevÄƒrat
                formula.append([a_lit, b_lit])
                valid = True
            attempts += 1

        if not valid:
            # Caz de urgenÈ›Äƒ dacÄƒ nu gÄƒsim clauzÄƒ validÄƒ
            formula.append([random.choice(vars_list), random.choice(vars_list)])

    if force_unsat:
        # AdÄƒugÄƒm contradicÈ›ie controlatÄƒ
        x = random.choice(vars_list)
        formula.extend([
            [x, x],
            [f"-{x}", f"-{x}"]
        ])

    # Verificare finalÄƒ de consistenÈ›Äƒ
    if not force_unsat:
        # Verificare finalÄƒ de consistenÈ›Äƒ
        assert dpll(formula.copy(), verbose=False)[0], "Formula generatÄƒ trebuie sÄƒ fie satisfiabilÄƒ!"
    return formula
def formula_to_string(formula):
    return " âˆ§ ".join(f"({a} âˆ¨ {b})" for a, b in formula)


def print_formula_tabel(formula):
    """AfiÈ™eazÄƒ formula Ã®n format tabelar"""
    print("\nFormula Ã®n format tabelar:")
    print("Clauza | Literal 1 | Literal 2")
    print("-" * 30)
    for i, clause in enumerate(formula, 1):
        if len(clause) != 2:
            print(f"ClauzÄƒ invalidÄƒ la poziÈ›ia {i}: {clause}")
            continue
        l1, l2 = clause
        print(f"{i:^6} | {str(l1):^8} | {str(l2):^8}")
def scoate_tautologii(formula):
    clean_formula = []
    for clause in formula:
        is_tautology = False
        for lit in clause:
            neg_lit = f"-{lit}" if not lit.startswith('-') else lit[1:]
            if neg_lit in clause:
                is_tautology = True
                break
        if not is_tautology:
            clean_formula.append(clause)
    return clean_formula
def resolve(c1, c2):
    """GenereazÄƒ rezolventele ne-tautologice pentru douÄƒ clauze."""
    resolvents = []
    for lit in c1:
        neg_lit = lit[1:] if lit.startswith('-') else f"-{lit}"
        if neg_lit in c2:
            new_clause = (c1 | c2) - {lit, neg_lit}
            # VerificÄƒ dacÄƒ rezolventul este tautologie
            is_tautology = any(
                (l in new_clause and f"-{l}" in new_clause)
                or (f"-{l}" in new_clause and l in new_clause)
                for l in new_clause
            )
            if not is_tautology:
                resolvents.append(new_clause)
    return resolvents

def resolutie_solver(formula, verbose=False, max_steps=100):
    formula = [set(clause) for clause in formula]
    formula = scoate_tautologii(formula)  # EliminÄƒ tautologiile iniÈ›iale
    derived = set()
    step = 0

    if verbose:
        print("\n[REZOLUÈšIE] Pas 0: Formula iniÈ›ialÄƒ")
        for i, clause in enumerate(formula, 1):
            print(f"Clauza {i}: {clause}")

    while step < max_steps:
        new_clauses = []
        pairs = [(i, j) for i in range(len(formula)) for j in range(i + 1, len(formula))]

        for i, j in pairs:
            c1 = formula[i]
            c2 = formula[j]
            resolvents = resolve(c1, c2)  # GenereazÄƒ rezolvente ne-tautologice

            for res in resolvents:
                if not res:  # Clauza vidÄƒ = contradicÈ›ie
                    if verbose:
                        print("â•" * 60)
                        print("â— ContradicÈ›ie Ã®n rezoluÈ›ia clauzelor:")
                        print(f"   Clauza {i + 1}: {c1}")
                        print(f"   Clauza {j + 1}: {c2}")
                        print("â•" * 60)
                    return False

                frozen_res = frozenset(res)
                if frozen_res not in derived:
                    derived.add(frozen_res)
                    new_clauses.append(res)

        # EliminÄƒ tautologiile din noile clauze generate
        new_clauses = scoate_tautologii(new_clauses)

        if verbose and new_clauses:
            print(f"\n[REZOLUÈšIE] Pas {step + 1}:")
            print(f"Clauze noi generate ({len(new_clauses)}):")
            for clause in new_clauses:
                print(f"  â€¢ {clause}")

        if not new_clauses:
            if verbose:
                print("Nu s-au generat clauze noi - Formula SATISFIABILÄ‚")
            return True

        formula += new_clauses
        step += 1

    if verbose:
        print("LimitÄƒ de paÈ™i depÄƒÈ™itÄƒ - Nu s-a putut determina satisfiabilitatea")
    return None


def run_tests_from_file(filename, algorithm, verbose=False):
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            tests = f.readlines()

        print(f"\n{'=' * 60}\nâš™ï¸ TESTARE DIN FIÈ˜IER: {filename}\n{'=' * 60}")

        results = []
        for line in tests:
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            if ';' not in line:
                print(f"\nâš ï¸ Linie ignoratÄƒ (format invalid): {line}")
                continue

            formula_str, expected = line.split(';', 1)
            expected = expected.upper().strip()

            print(f"\nâ¡ï¸ TEST: {formula_str}")
            print(f"   AÈ™teptat: {expected}")

            formula = formula_parsata(formula_str)
            if not formula:
                print("âŒ EROARE PARSARE - TEST IGNORAT")
                results.append(False)
                continue

            try:
                if algorithm == '1':
                    ok, _ = dpll(formula, verbose=verbose)
                    result_str = 'SAT' if ok else 'UNSAT'
                elif algorithm == '2':
                    ok = dp(formula, verbose=verbose)
                    result_str = 'SAT' if ok else 'UNSAT'
                elif algorithm == '3':
                    ok = resolutie_solver(formula, verbose=verbose)
                    result_str = 'SAT' if ok else 'UNSAT'
                else:
                    print(f"âŒ Algoritm invalid: {algorithm}")
                    result_str = 'EROARE'
            except Exception as e:
                print(f"âŒ Eroare la executie: {str(e)}")
                result_str = 'EROARE'

            match = (result_str == expected)
            results.append(match)
            print(f"   Rezultat: {result_str} | {'âœ… CORECT' if match else 'âŒ INCORECT'}")

        passed = sum(results)
        total = len(results)
        print(f"\n{'=' * 60}\nğŸ“Š REZULTATE FINALE: {passed}/{total} corecte ({passed / total * 100:.1f}%)\n{'=' * 60}")

    except FileNotFoundError:
        print(f"\nâŒ FiÈ™ierul {filename} nu existÄƒ!")
    except Exception as e:
        print(f"\nâŒ Eroare la procesarea fiÈ™ierului: {str(e)}")
def run():
    print("\n" + "=" * 60)
    print(" " * 10 + "SISTEM AVANSAT DE VERIFICARE SAT 2-CNF")
    print("=" * 60)
    print("InstrucÈ›iuni:")
    print("- FoloseÈ™te âˆ¨ pentru SAU, âˆ§ pentru È˜I")
    print("- Negare: - (ex: -a sau -1)")
    print("- Variabilele pot conÈ›ine litere È™i cifre (x1, var2)")
    print("- Exemple valide:")
    print("  (a âˆ¨ -b) âˆ§ (c âˆ¨ d)")
    print("  (1 âˆ¨ -2) âˆ§ (-3 âˆ¨ 4)")
    print("=" * 60)


    options = [
        "1: Introducere manualÄƒ formulÄƒ",
        "2: Generare automatÄƒ formulÄƒ",
        "3: Testare din fiÈ™ier",
        "4: IeÈ™ire"
    ]
    print("\n".join(options))
    choice = input("\nAlegeÈ›i opÈ›iunea: ").strip()
    if choice == '1':
        input_formula = input("\nIntroduceÈ›i formula:\n>> ").strip()
        formula = formula_parsata(input_formula)
        if not formula:
            print("\nâŒ Formula invalidÄƒ! Trebuie sÄƒ respecte urmÄƒtoarele:")
            print("- Fiecare clauzÄƒ Ã®ntre paranteze: (literal âˆ¨ literal)")
            print("- Literalii pot fi: variabilÄƒ (a-z, 0-9) sau -variabilÄƒ")
            print("- Conector âˆ§ Ã®ntre clauze")
            print("Exemplu corect: (a âˆ¨ -b) âˆ§ (c âˆ¨ d) âˆ§ (-x âˆ¨ y)")
            return
        verbose=input("Afisare pasi detaliata? (da/nu): ").lower() == 'da'
        print_formula_tabel(formula)  # Mutat dupÄƒ verificarea validitÄƒÈ›ii

    elif choice == '2':
        print("\n[INFO] Generare automatÄƒ de formulÄƒ 2-CNF:")
        n_vars = int(input("  - NumÄƒr de variabile: "))
        n_clauses = int(input("  - NumÄƒr de clauze: "))
        force_unsat = input("  - Vrei ca formula sÄƒ fie nesatisfiabilÄƒ? (da/nu): ").strip().lower() == 'da'
        formula = genereaza_2cnf_formula(n_vars, n_clauses, force_unsat)
        print("\n[INFO] Formula generatÄƒ:")
        print(" ", formula_to_string(formula))
        print_formula_tabel(formula)
        verbose = input("Afisare pasi detaliati? (da/nu): ").lower() == 'da'
    elif choice == '3':
        filename = input("\nIntroduceÈ›i numele fiÈ™ierului cu teste (ex: teste.txt): ").strip()
        print("\nAlege algoritmul de rezolvare:")
        print("1. DPLL (Davisâ€“Putnamâ€“Logemannâ€“Loveland)")
        print("2. DP (RezoluÈ›ie clasicÄƒ)")
        print("3. RezoluÈ›ie clasicÄƒ (completÄƒ)")
        alg = input(">> ").strip()
        verbose = input("Afisare pasi detaliata pentru fiecare test? (da/nu): ").lower() == 'da'
        run_tests_from_file(filename, alg, verbose)
        return
    elif choice == '4':
        return
    else:
        print("\n[Eroare] OpÈ›iune invalidÄƒ. ÃncearcÄƒ din nou.")
        return

    print("\nAlege algoritmul de rezolvare:")
    print("1. DPLL (Davisâ€“Putnamâ€“Logemannâ€“Loveland)")
    print("2. DP (RezoluÈ›ie clasicÄƒ)")
    print("3. RezoluÈ›ie clasicÄƒ (completÄƒ)")
    alg = input(">> ").strip()

    print("\n" + "-" * 60)
    import time
    start_time = time.time()

    if alg == '1':
        print("\n[INFO] Rulare DPLL cu optimizÄƒri...")
        ok, result = dpll(formula, verbose=verbose)
        elapsed = time.time() - start_time

        print("\n=== REZULTATE ===")
        print(f"Timp execuÈ›ie: {elapsed:.4f} secunde")
        if ok:
            print("âœ… SATISFIABILÄ‚")
            clean_result = {lit.replace("(", "").replace(")", "") if isinstance(lit, str) else lit for lit in result}
            print("Atribuire minimÄƒ:", sorted(clean_result, key=lambda x: str(x)))
            print("\nValidare manualÄƒ:")
            for i, clause in enumerate(formula, 1):
                sat = any(lit in clean_result for lit in clause)
                print(f"Clauza {i}: {clause} {'âœ“' if sat else 'âœ—'}")
        else:
            print("âŒ NESATISFIABILÄ‚")

    elif alg == '2':
        print("\n[INFO] Rulare algoritm DP...")
        ok = dp(formula, verbose=verbose)
        print("\n=== REZULTAT DP ===")
        print("âœ… SATISFIABILÄ‚" if ok else "âŒ NESATISFIABILÄ‚")

    elif alg == '3':
        print("\n[INFO] Rulare RezoluÈ›ie clasicÄƒ...")
        ok = resolutie_solver(formula, verbose=verbose)
        elapsed = time.time() - start_time
        print("\n=== REZULTATE REZOLUÈšIE ===")
        print(f"Timp execuÈ›ie: {elapsed:.4f} secunde")
        print("âŒ NESATISFIABILÄ‚" if not ok else "âœ… SATISFIABILÄ‚")

    else:
        print("OpÈ›iune invalidÄƒ!")

    print("=" * 60)


if __name__ == "__main__":
    run()
